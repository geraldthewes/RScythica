\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{RScythica - A Memory Mapped Data Set}

\author{Gerald Hewes}

\maketitle

\tableofcontents

\section{Introduction}

RScythica Dataframes, also called S Dataframes, are large scale, read-only, memory-mapped
data sets which are both partioned and
broken into large splits. S Dataframes are created using external utilities.

\subsection{Background}

Scythica was developed to help data scientist analyze large datasets in R. Key features are:

\begin{itemize}
  \item S Datasets consists of multiple binary files that hold data in columns of vectors. The files are   mapped directly into an R process using R 3.1.0 support for custom allocators. The data is pre-processed by external utilities. Since R memory maps the data directly into it's process, access is very fast and much more efficient.
  \item Data is by default partitioned by one of the dataset columns. For example in ad tech it is common to partition data by date.
  \item To handle really large partitions, the partitions can be broken into multiple splits.
Effectivily the key to a vector consists of the partition plus the split index.
\end{itemize}


\section{Simple Example}

Typically you receive data in a large CSV file. Before it can be used in R, the CSV file need to be transformed in a binary Scythica dataset.

\subsection{Creating a Dataset}

The first step is creating the necessary configuration file in YAML format. RScythica comes with a utily function to generate a templated configration

<<>>=
library(yaml)
library(RScythica)
# Use read.table to read 100 rows
sample <- read.table('../tests/extdata/airline.csv',sep=',', header=TRUE, nrows=100)
# Create a templated file that can be edited
makeconfig('example.yaml',sample)
@

Talk about partitions...

Then process the CSV file using the sdscreate executable

<<eval=FALSE>>=
#sdscreate airline.yaml airline.sds airline.csv
@

\subsection{Basic Usage of Datasets}


<<>>=
library(RScythica)

#Open Dataset
ds <- open_sdataset("../tests/extdata/airline.sds")
print(ds)

# Return number of columns in the dataset
ds$ncol()

# Return the column names and types in the dataset
ds$names()
ds$col_types()

# List all the partitions in the dataset
ds$partitions()

# Return number of rows in a given partition
ds$partition_rows('2008-01-03')

# Extract a vector given a partition, split and column index
v <- ds$split('2008-01-03',1,19)

# Or equivalently use column name
v <- ds$splitn('2008-01-03',1,"AirTime")

# Or even simpler use [ where partition and split are combined with :
v <- ds["2008-01-03:1","AirTime"]

# To exact all the columns in a dataframe use as_data_frame_split
df <- as_data_frame_split(ds,'2008-01-03')
@

\subsection{Iterators}

Iterators allow you to iterate over all the partions and splits.

<<>>=
it <- sdf_iterator(ds)
c <- nextElem(it)
c

# Iterate over all partitions and split and do a sum
s <- foreach(i=sdf_iterator(ds),.combine=sum) %do% ds$split(i$pkey,i$split,19)
s
@



\section{Filters}

Filter operations allow you to select only some rows from a dataset.

<<>>=

m   <- Module("rscythica", PACKAGE="RScythica")
# Create an Integer Vector
bm <- m$SIntVector
bm.v <- new(bm)

v <- ds$split('2008-01-03',1,19)

# Create Filter BitVector
ob <- sindex(length(v))

# Apply == 515
y <- bm.v$op.eq(v,ob,515)
y

# Apply > 1000 & < 1500
a <- bm.v$op.gt(v,ob,1000)
ob2 <- sindex(length(v))
b <- bm.v$op.lt(v,ob2,1500)
c <- sindex(length(v))
bm <- m$BitVector
bv <- new(bm,a)
ov <- bv$op.and(c, b)
res <-  bm.v$collapse(v,ov)
res

# Number of True 
bm <- m$BitVector
bv <- new(bm,y)
bv$popcount()


# Filter row using BitVector
out <- bm.v$collapse(v,y)
length(out)
out

@


\end{document}